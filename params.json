{"name":"emb6","tagline":"emb6 is a scalable C-based 6LoWPAN stack for embedded devices","body":"<img src=\"https://raw.github.com/hso-esk/_meta/master/fh-offenburg_schrift_2010_72dpi.png\" width=\"300\">\r\n<img src=\"https://raw.github.com/hso-esk/_meta/master/ei-fb_rgb_300.jpg\" width=\"300\">\r\n\r\nemb6\r\n========\r\n\r\n`emb6` is a scalable C-based 6LoWPAN stack for embedded devices developed by the\r\n[*Labratory of Communication Electronics and Embedded Devices (ESK)*](http://ei.hs-offenburg.de/labore/embedded-systems-und-kommunikationselektronik/) at\r\n[*Offenburg University of Applied Siences (HSO)*](http://www.hs-offenburg.de/) under supervision of *Prof. Dr. Axel Sikora* (axel.sikora@hs-offenburg.de).\r\n\r\nOriginally derived from Contiki several adaptations have been made such as the\r\nremoval of proto-threads. It follows a strict layer based architecture with a\r\nmodular software design allowing it to be used even on very restricted devices.\r\n\r\n\r\nIntroduction\r\n------------\r\n\r\nIn the last decade, IPv6 over Low power Wireless Personal Area Networks, also\r\nknown as 6LoWPAN, has well evolved as a primary contender for short range\r\nwireless communication and holds the promise of an Internet of Things, which is\r\ncompletely based on the Internet Protocol. The IEEE 802.15.4 standard specifies\r\na maximum frame size of 127 bytes where the IPv6 specification requires a\r\nminimum MTU of 1280 byte. With the 6LoWPAN adaptation layer it is possible to\r\nmake use of IPv6 in small and constrained wireless networks which follows the\r\nIEEE 802.15.4 standard. In the meantime, various 6LoWPAN implementations are\r\navailable, be it open source or commercial. One of the open source\r\nimplementations is the C-based `emb6` stack.\r\n\r\nThe `emb6` stack is optimized to be used in constrained devices without an\r\noperation system. The stack operates event driven with a scalable buffer\r\nhandling for optimization on different platforms. The typical field of\r\napplication is in wireless sensor networks, e.g. for home automation or\r\nindustrial environments.\r\n\r\n\r\nGetting started\r\n---------------\r\n\r\nFor the best introduction to get started with `emb6`, please read the\r\ndocumentation included. For the code comments you will also find a doxygen\r\nproject file within the doc folder.\r\n\r\nFeatures\r\n---------\r\n\r\n### Functionality\r\n\r\nThere are several IOT capable stacks available may it be on open source or on\r\ncommercial basis. The `emb6` networking stack provides several salient features\r\nmaking it a unique offering. The main features and concepts of the stack are the\r\nfollowing:\r\n\r\n* **Event Driven Operation** - Very small RAM overhead, one memory stack for the\r\nwhole system.      \r\n* **Scalable Buffer Handling** - A common buffer module is used across layer and\r\nmodule boundaries. This decreases memory usage and furthermore provides\r\nscalability for usage on different hardware configurations and limitations.\r\n* **Static memory management** - For additional stability during runtime.\r\n* **Compile Time Options** - Usage of different compile-time settings help to\r\nmake an optimum selection regarding to the anticipated use cases as well as to\r\nthe hardware limitations such as memory size or computing performance.\r\n* **Run Time Options** - Many stack parameters are accessible and changeable\r\nduring runtime via remote management.\r\n* **Full IPv6 support** - The integrated IPv6 protocol is based on the\r\nuIP-Stack. This provides full IPv6 support and guarantees further support\r\nand maintenance.\r\n* **BSP and HAL Abstraction** - Hardware dependencies are abstracted with a BSP\r\nwhich offers an API between the target and the applications and with a hardware\r\nabstraction layer HAL, which allows independence from the used\r\nmicrocontroller IC.\r\n* **Optimized for use in constrained devices**- The scalability of the stack\r\nenables a manifold use in highly diverse embedded systems.\r\n* **Routing functionality** - The routing functionality is provided by the RPL\r\nprotocol.\r\n* **Layered Architecture** - The design of the software stack follows a strict\r\nlayered architecture.\r\n* **Simple Setup and Configuration** - The setup and configuration can be easily\r\nexecuted with the help of centralized configuration files.\r\n* **Socket Interface**- A BSD like socket API allows easy integration of\r\ncustomized applications.\r\n* **Set of included Application Layer Protocols** - e.g. COAP (further will follow)\r\n\r\n\r\n### Build System\r\n\r\nThe buildsystem of `emb6` is completely based on SCons as a replacement for make\r\nwith improved features. SCons is based on Python, makeing the tool very powerful\r\nfor the build process. It allows to easily create new configurations e.g. regarding\r\nMCU/Transceiver or application selection. Furhermore the build-time is decreased\r\nsignificantly.\r\n\r\n### Supported Targets\r\n\r\n`emb6` is very platform independent since it has no requirements to an OS and\r\nhardware access is abstracted in a simple \"single-file-based\" hardware\r\nabstraction layer. That makes it quite easy to port `emb6` to other platforms.\r\nHowever `emb6` comes with support of several platforms by default:\r\n\r\n\r\nTarget | MCU | TRANSCEIVER\r\n-------|-----| ------------\r\n**atany900** | atmega1281 | at86rf212\r\n**atany900pro3** | samd21g18a | at86rf212b\r\n**atany900pro5** | samd20g18 | at86rf212b\r\n**atany900basic** | samd20g18 | at86rf212b\r\n**xpro_212** | samd20j18 | at86rf212\r\n**xpro_212b** | samd20j18 | at86rf212b\r\n**stk3600** | efm32lg990f256 | at86rf212b\r\n\r\n\r\nContact\r\n--------\r\n\r\nFor questions or recommendations don't hesitate to contact emb6@hs-offenburg.de\r\n\r\n[1]: http://ei.hs-offenburg.de/labore/embedded-systems-und-kommunikationselektronik/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}